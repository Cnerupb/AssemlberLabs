.data
output_block:
    .align 4                    @ Выровняем блок на границу 4 байт
    .word 0, 0, 0               @ Блок для передачи дескриптора, буфера и длины

char_array:   .asciz "  Hello World, This is a SAMPLE Sentence.  "
char_output:  .skip 80
blank_line:   .asciz "\n"

.text
.global _start

_start:
    ldr r1, =char_array            @ Адрес входной строки
    ldr r2, =char_output           @ Адрес буфера для изменённой строки
    mov r3, #0                     @ Индекс для записи в выходной буфер
    mov r4, #0                     @ Флаг предыдущего символа (0 - не пробел, 1 - пробел)

process_char:
    ldrb r5, [r1], #1              @ Загружаем байт из входной строки и увеличиваем указатель
    cmp r5, #0                     @ Проверяем конец строки (нулевой байт)
    beq print_output               @ Если конец строки, выводим изменённую строку

    cmp r5, #' '                   @ Проверяем, является ли символ пробелом
    beq handle_space               @ Если пробел, обрабатываем его

    cmp r5, #'A'                   @ Проверяем, заглавная ли буква
    blt copy_char                  @ Если меньше 'A', оставляем без изменений
    cmp r5, #'Z'                   @ Проверяем, не выходит ли за пределы заглавных букв
    bgt copy_char                  @ Если больше 'Z', оставляем без изменений

    add r5, r5, #'a' - 'A'         @ Преобразуем заглавную букву в строчную

copy_char:
    strb r5, [r2, r3]              @ Записываем символ в выходной буфер
    add r3, r3, #1                 @ Увеличиваем индекс выходного буфера
    mov r4, #0                     @ Сбрасываем флаг пробела
    b process_char                 @ Переходим к следующему символу

handle_space:
    cmp r4, #1                     @ Проверяем, был ли предыдущий символ пробелом
    beq process_char               @ Если да, пропускаем текущий пробел
    strb r5, [r2, r3]              @ Иначе записываем пробел в выходной буфер
    add r3, r3, #1                 @ Увеличиваем индекс выходного буфера
    mov r4, #1                     @ Устанавливаем флаг пробела
    b process_char                 @ Переходим к следующему символу

print_output:
    mov r0, #1                    @ Устанавливаем дескриптор stdout
    ldr r1, =char_output          @ Адрес буфера с изменённой строкой
    mov r2, r3                    @ Длина строки

    ldr r3, =output_block         @ Настройка блока вывода
    str r0, [r3]                  @ Устанавливаем дескриптор (stdout)
    str r1, [r3, #4]              @ Устанавливаем адрес буфера
    str r2, [r3, #8]              @ Устанавливаем длину строки

    mov r0, #0x05                 @ Код операции (пишем в stdout)
    mov r1, r3                    @ Адрес блока данных
    swi 0x123456                  @ Выполняем системный вызов

    @ Вывод новой строки
    mov r0, #1
    ldr r1, =blank_line
    mov r2, #1
    swi 0x123456

    @ Завершаем программу
    mov r0, #0x18
    swi 0x123456
