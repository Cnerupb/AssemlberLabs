.data
output_block:
    .align 4                    @ Выровняем блок на границу 4 байт
    .word 0, 0, 0               @ Блок для передачи дескриптора, буфера и длины

char_array:   .asciz "   Hello World, This is ad SAMPLE Sentence! ##%^() Contains  ad lot    of spaces"         @   Hello World, This is a SAMPLE Sentence.  Contains  a lot    of spaces   
char_output:  .skip 80
blank_line:   .asciz "\n"
word_not_found: .asciz "Word not found"

.text
.global _start

_start:
    ldr r1, =char_array             @ Адрес входной строки
    mov r2, #81                     @ Длина самого короткого слова
    mov r3, #-1                     @ Индекс текущего символа
    mov r4, #0                      @ Хранит подсчитываемую длину слов
    mov r6, #-1                     @ Индекс начала минимального слова

process_char:
    ldrb r5, [r1], #1               @ Загружаем байт из входной строки и увеличиваем указатель

    cmp r5, #0                      @ Проверяем на конец строки (нулевой байт)
    beq calc_end                    @ Если конец строки, проводим последние вычисления

    add r3, r3, #1                  @ Увеличиваем индекс текущего символа на единицу (по умолчанию = -1)

    cmp r5, #' '                    @ Проверяем, является ли символ пробелом
    beq handle_space                @ Если да, переходим к обработке пробела

    add r4, r4, #1                  @ Увеличиваем длину текущей подпоследовательности на 1 (по умолчанию = 0)
    
    b process_char                  @ Переходим на следующую итерацию

handle_space:
    cmp r4, #0                      @ Если длина текущей подпоследовательности = 0
    beq process_char                @ То переходим к следующей итерации пропуская обработку пробела

    cmp r4, r2                      @ Сравниваем подсчитанную сейчас длину с запомненной
    blt update_min_len              @ Если подсчитанная меньше, то обновляем индексы и длины

    mov r4, #0                      @ Сбрасываем посчитанную сейчас длину слова для следующих итераций
    b process_char

update_min_len:
    mov r2, r4                      @ Обновляем минимальную длину
    mov r6, r3                      @ Обновляем индекс конца слова минимальной длины индексом пробела, идущего после этого слова
    mov r4, #0                      @ Сбросить подсчитанную длину посчитанного сейчас слова для следующих итераций
    b process_char

calc_end:
    cmp r4, #0                      @ Если длина в конце равна 0, 
    beq check_len                   @ То переходим к проверке найденных длин 

    cmp r4, r2                      @ Если подсчитанная длина больше либо равна запомненной,
    bge check_len                   @ То переходим к проверке найденных длин 
    @ Иначе обновляем минимальную длину и связанные индексы

update_min_len_at_end:
    mov r2, r4                      @ Обновляем минимальную длину
    mov r6, r3                      @ Обновляем индекс начала слова минимальной длины
    mov r4, #0                      @ Сбросить подсчитанную длину текущего слова для следующих итераций

check_len:
    cmp r2, #81                     @ Если найденная длина не изменялась и равна по умолчанию 81
    beq print_empty_word            @ То выводим на экран сообщение "Слово не найдено"

    ldr r1, =char_array             @ Загружаем в r1 исходный массив символов
    mov r3, #0                      @ Счётчик для сравнения с длинной
    ldr r4, =char_output            @ Загружаем в r4 массив для записи слова

    sub r6, r6, r2                  @ Индекс начала минимального слова = индекс конца - длина слова
    add r1, r1, r6                  @ Переходим на начало минимального слова

copy_symbol:
    cmp r2, r3                      @ Сравнение счётчика с длинной
    beq print_output                @ Если они равны, то переходим к выводу

    ldrb r5, [r1], #1               @ Загружаем текущий символ в r5 и переходим к следующему
    strb r5, [r4], #1               @ Сохраняем его в результирующий массив символов
    add r3, r3, #1                  @ Увеличиваем счётчик на 1

    b copy_symbol

print_output:
    mov r0, #1                    @ Устанавливаем дескриптор stdout
    ldr r1, =char_output          @ Адрес буфера с изменённой строкой
    mov r2, r3                    @ Длина строки

    ldr r3, =output_block         @ Настройка блока вывода
    str r0, [r3]                  @ Устанавливаем дескриптор (stdout)
    str r1, [r3, #4]              @ Устанавливаем адрес буфера
    str r2, [r3, #8]              @ Устанавливаем длину строки

    mov r0, #0x05                 @ Код операции (пишем в stdout)
    mov r1, r3                    @ Адрес блока данных
    swi 0x123456                  @ Выполняем системный вызов

    @ Вывод новой строки
    mov r0, #1
    ldr r1, =blank_line
    mov r2, #1
    swi 0x123456

    @ Завершаем программу
    mov r0, #0x18
    swi 0x123456

print_empty_word:
    ldr r1, =word_not_found       @ Адресс строки "Word not found"
    mov r2, #14                   @ Длина строки

    ldr r3, =output_block         @ Настройка блока вывода
    str r0, [r3]                  @ Устанавливаем дескриптор (stdout)
    str r1, [r3, #4]              @ Устанавливаем адрес буфера
    str r2, [r3, #8]              @ Устанавливаем длину строки

    mov r0, #0x05                 @ Код операции (пишем в stdout)
    mov r1, r3                    @ Адрес блока данных
    swi 0x123456                  @ Выполняем системный вызов

    @ Вывод новой строки
    mov r0, #1
    ldr r1, =blank_line
    mov r2, #1
    swi 0x123456

    @ Завершаем программу
    mov r0, #0x18
    swi 0x123456